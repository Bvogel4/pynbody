"""
Routines and derived arrays for calculating luminosities and magnitudes.

This module provides a number of routines for calculating luminosities and magnitudes
starting from the stellar populations in a simulation.

Two sets of derived arrays are programmatically generated. The first set is the
magnitude of a stellar particle in a given bandpass, e.g. 'v_mag'. The second set is
the luminosity density, encoded as 10^{-0.4 * mag} per unit volume, e.g. 'v_lum_den'.
The purpose of the luminosity density array is that, when integrated over a line of sight,
it becomes a number of magnitudes per unit area (e.g. mag/kpc^2), which can then be
turned into an astronomical surface brightness (mag/arcsec^2) -- this approach is taken
by the :func:`pynbody.plot.stars.render` routine.

The above arrays are generated for all known bandpasses in the CMD.

Origin of the luminosity tables
-------------------------------

Luminosities in pynbody are calculated by treating each star particle as a single
stellar population (SSP) of a known age and metallicity, assuming a fixed initial
mass function (IMF). Magntiudes for each star particle can then be interpolated
from a table, for the known UBVRIJHK bandpasses.

The SSP tables provided are computed using CMD 3.7, via the web interface at
http://stev.oapd.inaf.it/cgi-bin/cmd_3.7 . There are a number of reasons why you
may wish to use a custom set of SSPs:

 * You wish to use a different set of stellar evolution assumptions;
 * You wish to use a different set of bandpasses;
 * You wish to assume a different IMF;
 * You wish to include interstellar dust extinctions (by default, only circumstellar
   dust is included, and dust extinction is optionally applied separately when rendering
   images; see the :func:`pynbody.plot.stars.render` documentation for more information).

If making your own tables using CMD, ensure that you opt for a grid of ages and metallicities
and a single-burst stellar population for 1 Msol of stars. These crucial options are near the
bottom of the web interface (as of May 2024). For the default table included with pynbody,
the requested table has log(age/yr) between 6.6 and 10.2 dex in steps of 0.1 dex, and the
metallicities between -2 and 0.2 dex solar in steps of 0.2 dex.  Note that ages and metallicities lying
outside the tabulated range are clamped to the edge of the table.

All other options are left as per the CMD 3.7 defaults in the default table. This results in the
following header information in the SSP tables, giving more context around the underlying
assumptions:

.. code-block:
    # File generated by CMD 3.7 (http://stev.oapd.inaf.it/cmd) on Fri May 10 10:02:59 UTC 2024
    # isochrones based on PARSEC release v1.2S +  COLIBRI S_37 + S_35 + PR16
    # Basic references: Bressan et al. (2012), MNRAS, 427, 127 + Chen et al. (2014, 2015), MNRAS, 444, 2525 + MNRAS, 452, 1068 + Tang et al. (2014), MNRAS, 445, 4287 + Marigo et al. (2017), ApJ, 835, 77 + Pastorelli al. (2019), MNRAS, 485, 5666 + Pastorelli al. (2020), MNRAS, in press
    # Thermal pulse cycles included
    # On RGB, assumed Reimers mass loss with efficiency eta=0.2
    # LPV periods and growth rates added cf. Trabucchi et al. (2019)
    # but fundamental-mode LPV periods are from Trabucchi et al. (2021)
    # Photometric system: <i>UBVRIJHK</i> (cf. Maiz-Apellaniz 2006 + Bessell 1990)
    # Using YBC version of bolometric corrections as in Chen et al. (2019)
    # O-rich circumstellar dpmod60alox40 dust from Groenewegen (2006)
    # C-rich circumstellar AMCSIC15 dust from Groenewegen (2006)

It also outputs the following filter information:

Filter	U	B	V	R	I	J	H	K
λeff (Å)	3598.54	4385.92	5490.56	6594.72	8059.88	12369.26	16464.45	22105.45
ωeff (Å)	584	913	857	1591	1495	2047	2854	3646
Aλ/AV	1.55814	1.32616	1.00096	0.80815	0.59893	0.28688	0.18103	0.11265

"""

import functools
import os

import numpy as np

from .. import filt, snapshot
from .interpolate import interpolate2d

_cmd_lum_file = os.path.join(os.path.dirname(__file__), "cmdlum.npz")

def use_custom_cmd(path):
    """Use a custom set of stellar populations to calculate magnitudes.

    The path is to a numpy archive with a suitable grid of ages/metallicities and corresponding magnitudes.

    The following script from Stephanie De Beer should help you make a suitable file starting
    from ugriz SSPs downloaded from http://stev.oapd.inaf.it/cgi-bin/cmd.

    import numpy as np

    metals = np.linspace(0.002, 0.05, 25)
    ages = np.logspace(5.67, 10.13, 25)

    mags_bol = np.zeros((len(metals),len(ages)))
    mags_u = np.zeros((len(metals),len(ages)))
    mags_g = np.zeros((len(metals),len(ages)))
    mags_r = np.zeros((len(metals),len(ages)))
    mags_i = np.zeros((len(metals),len(ages)))
    mags_z = np.zeros((len(metals),len(ages)))

    bands = ['bol', 'u', 'g', 'r', 'i', 'z']
    k=2
    for b in bands:
        for x in range(1,26):
            with open('/users/sdebeer/render_stuff/PGSP_files/'+str(x)+'_output.txt', 'r') as f:
                output = f.readlines()
            i = 0
            for line in output:
                magnitudes = line.split()
                if magnitudes[0]=='#':
                    continue
                vars()['mags_'+b][i,x-1]=magnitudes[k]
                i +=1
        k+=1

    np.savez('my_cmd.npz', ages=ages, metals=metals, bol=mags_bol, u=mags_u, g=mags_g, r=mags_r, i=mags_i, z=mags_z)
    """
    global _cmd_lum_file
    _cmd_lum_file = path

def calc_mags(simstars, band='v', cmd_path=None):
    """Calculating visible magnitudes

    Using Padova Simple stellar populations (SSPs) from Girardi
    http://stev.oapd.inaf.it/cgi-bin/cmd
    Marigo+ (2008), Girardi+ (2010)

    pynbody includes a grid of SSP luminosities for many bandpasses for
    various stellar ages and metallicities.  This function linearly
    interpolates to the desired value and returns the value as a magnitude.

    **Usage:**

    >>> import pynbody
    >>> pynbody.analysis.luminosity.calc_mags(h[1].s)

    **Optional keyword arguments:**

       *band* (default='v'): Which observed bandpass magnitude in which
            magnitude should be calculated

       *path* (default=None): Path to the CMD grid. If None, use the
            default or a path specified by use_custom_cmd. For more information
            about generating a custom CMD grid, see use_custom_cmd.

    """

    # find data file in PYTHONPATH
    # data is from http://stev.oapd.inaf.it/cgi-bin/cmd
    # Padova group stellar populations Marigo et al (2008), Girardi et al
    # (2010)
    if cmd_path is not None:
        lums = np.load(cmd_path)
    else:
        lums = np.load(_cmd_lum_file)


    age_star = simstars['age'].in_units('yr')
    # allocate temporary metals that we can play with
    metals = simstars['metals']
    # get values off grid to minmax
    age_star[np.where(age_star < np.min(lums['ages']))] = np.min(lums['ages'])
    age_star[np.where(age_star > np.max(lums['ages']))] = np.max(lums['ages'])
    metals[np.where(metals < np.min(lums['mets']))] = np.min(lums['mets'])
    metals[np.where(metals > np.max(lums['mets']))] = np.max(lums['mets'])

    age_grid = np.log10(lums['ages'])
    met_grid = lums['mets']
    mag_grid = lums[band]

    output_mags = interpolate2d(
        metals, np.log10(age_star), met_grid, age_grid, mag_grid)

    try:
        vals = output_mags - 2.5 * \
            np.log10(simstars['massform'].in_units('Msol'))
    except KeyError:
        vals = output_mags - 2.5 * np.log10(simstars['mass'].in_units('Msol'))

    vals.units = None
    return vals


def halo_mag(sim, band='v'):
    """Calculating halo magnitude

    Calls pynbody.analysis.luminosity.calc_mags for ever star in passed
    in simulation, converts those magnitudes back to luminosities, adds
    those luminosities, then converts that luminosity back to magnitudes,
    which are returned.

    **Usage:**

    >>> import pynbody
    >>> pynbody.analysis.luminosity.halo_mag(h[1].s)

    **Optional keyword arguments:**

       *band* (default='v'): Which observed bandpass magnitude in which
            magnitude should be calculated
    """
    if (len(sim.star) > 0):
        return -2.5 * np.log10(np.sum(10.0 ** (-0.4 * sim.star[band + '_mag'])))
    else:
        return np.nan


def halo_lum(sim, band='v'):
    """Calculating halo luminosiy

    Calls pynbody.analysis.luminosity.calc_mags for every star in passed
    in simulation, converts those magnitudes back to luminosities, adds
    those luminosities, which are returned.  Uses solar magnitudes from
    http://www.ucolick.org/~cnaw/sun.html.

    **Usage:**

    >>> import pynbody
    >>> pynbody.analysis.luminosity.halo_mag(h[1].s)

    **Optional keyword arguments:**

       *band* (default='v'): Which observed bandpass magnitude in which
            magnitude should be calculated
    """
    sun_abs_mag = {'u':5.56,'b':5.45,'v':4.8,'r':4.46,'i':4.1,'j':3.66,
                   'h':3.32,'k':3.28}[band]
    return np.sum(10.0 ** ((sun_abs_mag - sim.star[band + '_mag']) / 2.5))


def half_light_r(sim, band='v', cylindrical=False):
    '''Calculate half light radius

    Calculates entire luminosity of simulation, finds half that, sorts
    stars by distance from halo center, and finds out inside which radius
    the half luminosity is reached.

    If cylindrical is True compute the half light radius as seen from the z-axis.
    '''
    half_l = halo_lum(sim, band=band) * 0.5

    if cylindrical:
        coord = 'rxy'
    else:
        coord = 'r'
    max_high_r = np.max(sim.star[coord])
    test_r = 0.5 * max_high_r
    testrf = filt.LowPass(coord, test_r)
    min_low_r = 0.0
    test_l = halo_lum(sim[testrf], band=band)
    it = 0
    while ((np.abs(test_l - half_l) / half_l) > 0.01):
        it = it + 1
        if (it > 20):
            break

        if (test_l > half_l):
            test_r = 0.5 * (min_low_r + test_r)
        else:
            test_r = (test_r + max_high_r) * 0.5
        testrf = filt.LowPass(coord, test_r)
        test_l = halo_lum(sim[testrf], band=band)

        if (test_l > half_l):
            max_high_r = test_r
        else:
            min_low_r = test_r

    return test_r


def _setup_derived_arrays():

    bands_available = ['u', 'b', 'v', 'r', 'i', 'j', 'h', 'k', 'U', 'B', 'V', 'R', 'I',
                       'J', 'H', 'K']

    def _lum_den_template(band, s):
        val = (10 ** (-0.4 * s[band + "_mag"])) * s['rho'] / s['mass']
        val.units = s['rho'].units/s['mass'].units
        return val

    for band in bands_available:
        X = lambda s, b=str(band): calc_mags(s, band=b)
        X.__name__ = band + "_mag"
        X.__doc__ = band + " magnitude from analysis.luminosity.calc_mags"""
        snapshot.SimSnap.derived_array(X)

        lum_den = functools.partial(_lum_den_template, band)

        lum_den.__name__ = band + "_lum_den"
        lum_den.__doc__ = "Luminosity density in astronomy-friendly units: 10^(-0.4 %s_mag) per unit volume. " \
                          "" \
                          "The magnitude is taken from analysis.luminosity.calc_mags."%band
        snapshot.SimSnap.derived_array(lum_den)


_setup_derived_arrays()
